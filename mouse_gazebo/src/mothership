#!/usr/bin/env python3
import rospy
import tf_conversions

import numpy as np

from mouse_description.msg import MouseCommand
from mouse_description.msg import MouseData
from gazebo_msgs.srv import SetModelState
from gazebo_msgs.srv import SetModelStateRequest

N = rospy.get_param('launch/num_mice')

# DAQ
miceData = [None] * N

def mouseCallback(data, num):
	miceData[num] = data

# Estimate
def getEstimate():
	x, y, a, c = 0, 0, 0, 0
	for d in miceData:
		x += d.confidence * d.boxPos.x
		y += d.confidence * d.boxPos.y
		a += d.confidence * modhalfpi(d.boxPos.ang)
		c += d.confidence
	if c < 0.01:
		return 0, 0, 0, 0
	x /= c
	y /= c
	a /= c
	return x, y, a, c

def displayEstimate():
	x, y, a, _ = getEstimate()
	args = SetModelStateRequest()
	args.model_state.model_name = 'ghostbox'
	args.model_state.reference_frame = 'world'
	args.model_state.pose.position.x = x
	args.model_state.pose.position.y = y
	args.model_state.pose.position.z = 0
	q = tf_conversions.transformations.quaternion_from_euler(0, 0, a - np.pi/2)
	args.model_state.pose.orientation.x = q[0]
	args.model_state.pose.orientation.y = q[1]
	args.model_state.pose.orientation.z = q[2]
	args.model_state.pose.orientation.w = q[3]
	rospy.ServiceProxy('/gazebo/set_model_state', SetModelState)(args)

# Math helpers
def modpi(ang):
	while (ang > np.pi):
		ang -= 2 * np.pi
	while (ang < -np.pi):
		ang += 2 * np.pi
	return ang

def modhalfpi(ang): # for cubes
	while (ang > np.pi/2):
		ang -= np.pi/2
	while (ang < 0):
		ang += np.pi/2
	return ang

def dist(x1, y1, x2, y2):
	return np.sqrt((y1-y2)**2 + (x1-x2)**2)

def main():
	miceControl = []
	for i in range(N):
		rospy.Subscriber(f'mouse{i}/telemetry', MouseData, mouseCallback, i)
		miceControl.append(rospy.Publisher(f'mouse{i}/command', MouseCommand, queue_size=10))

	while not all(miceData):
		pass # wait for mice to bootup and send telemetry

	# TODO DEMO REMOVE LATER
	poses = [(1,0,np.pi/2), (0,1,np.pi), (-1,0,-np.pi/2), (0,-1,0)]

	r = rospy.Rate(30)
	while not rospy.is_shutdown():
		# TODO DEMO REMOVE LATER
		if sum([dist(miceData[i].pos.x, miceData[i].pos.y, poses[i][0], poses[i][1]) for i in range(N)]) < 0.01:
			poses = poses[1:] + [poses[0]]

		for i in range(N):
			cmd = MouseCommand()
			cmd.type = MouseCommand.POSITION
			cmd.x = poses[i][0]
			cmd.y = poses[i][1]
			cmd.ang = poses[i][2]
			miceControl[i].publish(cmd)

		# TODO Mod as needed, just visualization aid
		displayEstimate()

		r.sleep()

if __name__ == '__main__':
	rospy.init_node('mothership')
	try:
		main()
	except rospy.ROSInterruptException:
		pass